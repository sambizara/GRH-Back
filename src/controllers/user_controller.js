// controllers/user_controller.js
const { User, Salarie, Stagiaire } = require("../models/user_model");
const Contrat = require("../models/contrat_model");
const Stage = require("../models/stage_model");
const bcrypt = require("bcryptjs");

// üîπ V√©rifier si un salari√© peut √™tre encadreur (a un contrat actif)
const verifierEncadreur = async (encadreurId) => {
  if (!encadreurId) return true; // Encadreur optionnel
  
  const encadreur = await User.findById(encadreurId);
  if (!encadreur || encadreur.role !== "SALARIE") {
    throw new Error("L'encadreur doit √™tre un salari√© existant");
  }

  // V√©rifier si le salari√© a un contrat actif
  const contratActif = await Contrat.findOne({ 
    user: encadreurId, 
    statut: 'Actif'
  });

  if (!contratActif) {
    throw new Error("Le salari√© s√©lectionn√© n'a pas de contrat actif");
  }

  return true;
};

// üîπ R√©cup√©rer les salari√©s disponibles (avec contrat actif) - UNIQUE FONCTION
exports.getSalariesDisponibles = async (req, res) => {
  try {
    // R√©cup√©rer tous les salari√©s actifs
    const tousLesSalaries = await Salarie.find({ actif: true })
      .select('nom prenom matricule email telephone dateEmbauche')
      .sort({ nom: 1, prenom: 1 });

    if (tousLesSalaries.length === 0) {
      return res.status(200).json({
        success: true,
        salaries: [],
        total: 0,
        message: "Aucun salari√© trouv√©"
      });
    }

    // R√©cup√©rer les contrats actifs pour ces salari√©s
    const contratsActifs = await Contrat.find({ 
      statut: 'Actif',
      user: { $in: tousLesSalaries.map(s => s._id) }
    })
    .populate('user', 'nom prenom')
    .populate('service', 'nomService');

    // Cr√©er un Map des IDs des salari√©s avec contrat actif
    const salarieAvecContrat = new Map();
    contratsActifs.forEach(contrat => {
      if (contrat.user) {
        salarieAvecContrat.set(contrat.user._id.toString(), {
          contratId: contrat._id,
          typeContrat: contrat.typeContrat,
          dateDebut: contrat.dateDebut,
          dateFin: contrat.dateFin,
          posteContrat: contrat.poste,
          salaire: contrat.salaire,
          service: contrat.service
        });
      }
    });

    // Filtrer les salari√©s pour ne garder que ceux avec contrat actif
    const salariesDisponibles = tousLesSalaries.filter(s => 
      salarieAvecContrat.has(s._id.toString())
    ).map(salarie => {
      const infoContrat = salarieAvecContrat.get(salarie._id.toString());
      return {
        _id: salarie._id,
        nom: salarie.nom,
        prenom: salarie.prenom,
        matricule: salarie.matricule,
        email: salarie.email,
        telephone: salarie.telephone,
        dateEmbauche: salarie.dateEmbauche,
        // Informations du contrat
        contratId: infoContrat.contratId,
        typeContrat: infoContrat.typeContrat,
        dateDebutContrat: infoContrat.dateDebut,
        dateFinContrat: infoContrat.dateFin,
        salaire: infoContrat.salaire,
        service: infoContrat.service,
        posteActuel: infoContrat.posteContrat
      };
    });

    console.log(`üìä ${salariesDisponibles.length}/${tousLesSalaries.length} salari√©s disponibles (avec contrat actif)`);

    res.status(200).json({
      success: true,
      salaries: salariesDisponibles,
      total: salariesDisponibles.length,
      message: salariesDisponibles.length === 0 
        ? "Aucun salari√© avec contrat actif trouv√©" 
        : `${salariesDisponibles.length} salari√©(s) disponible(s) trouv√©(s)`
    });
  } catch (error) {
    console.error("‚ùå Erreur r√©cup√©ration salari√©s disponibles:", error);
    res.status(500).json({ 
      success: false,
      message: "Erreur serveur lors de la r√©cup√©ration des salari√©s disponibles", 
      error: error.message 
    });
  }
};

// üîπ Ajouter un nouvel utilisateur
exports.createUser = async (req, res) => {
  try {
    const { nom, prenom, email, password, sexe, dateNaissance, telephone, adresse, role } = req.body;

    // V√©rifier si email existe d√©j√†
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: "Email d√©j√† utilis√©" });
    }

    // Validation du r√¥le
    if (!["ADMIN_RH", "SALARIE", "STAGIAIRE"].includes(role)) {
      return res.status(400).json({ message: "R√¥le invalide." });
    }

    let newUser;

    if (role === "SALARIE") {
      const { dateEmbauche, matricule, situationFamiliale, nombreEnfants } = req.body;
      
      if (!dateEmbauche) {
        return res.status(400).json({ message: "dateEmbauche est obligatoire pour un salari√©." });
      }

      if (!matricule) {
        return res.status(400).json({ message: "Le matricule est obligatoire pour un salari√©." });
      }

      // V√©rifier si le matricule existe d√©j√†
      const existingMatricule = await Salarie.findOne({ matricule });
      if (existingMatricule) {
        return res.status(400).json({ message: "Matricule d√©j√† utilis√©" });
      }
      
      newUser = new Salarie({ 
        nom, prenom, email, password, sexe, dateNaissance, telephone, adresse, 
        dateEmbauche, matricule, situationFamiliale, nombreEnfants 
      });
    } 
    else if (role === "STAGIAIRE") {
      const { ecole, filiere, niveau, dureeStage, encadreur, poste } = req.body;
      
      if (!ecole || !filiere || !niveau || !dureeStage || !encadreur) {
        return res.status(400).json({ 
          message: "ecole, filiere, niveau, dureeStage et encadreur sont obligatoires pour un stagiaire." 
        });
      }

      // V√©rifier si l'encadreur existe et a un contrat actif
      if (encadreur) {
        await verifierEncadreur(encadreur);
      }
      
      newUser = new Stagiaire({ 
        nom, prenom, email, password, sexe, dateNaissance, telephone, adresse, 
        ecole, filiere, niveau, dureeStage, encadreur, poste,
        statutConfirmation: 'en_attente'
      });

      await newUser.save();

      // üîπ CR√âATION AUTOMATIQUE DU STAGE quand on cr√©e un stagiaire
      const stage = new Stage({
        stagiaire: newUser._id,
        encadreur: encadreur,
        sujet: `Stage en ${poste || 'd√©veloppement'} - ${filiere}`,
        dateDebut: new Date(),
        dateFin: new Date(new Date().setMonth(new Date().getMonth() + parseInt(dureeStage))),
        statut: 'En attente',
        confirmationEncadreur: {
          statut: 'en_attente'
        },
        objectifs: [
          `Acqu√©rir des comp√©tences en ${poste || 'd√©veloppement'}`,
          `Mettre en pratique les connaissances acquises en ${filiere}`,
          `Contribuer aux projets de l'entreprise`
        ],
        descriptifs: [
          `Stage de ${dureeStage} mois en ${poste || 'd√©veloppement'}`,
          `√âtudiant en ${niveau} - ${filiere}`
        ]
      });

      await stage.save();
      console.log("‚úÖ Stage cr√©√© automatiquement pour le stagiaire:", newUser._id);

      return res.status(201).json({ 
        message: "Stagiaire cr√©√© avec succ√®s", 
        user: newUser,
        stage: stage 
      });
    } 
    else {
      // ADMIN_RH
      newUser = new User({ 
        nom, prenom, email, password, sexe, dateNaissance, telephone, adresse, role 
      });
    }

    await newUser.save();
    
    res.status(201).json({ 
      message: "Utilisateur cr√©√© avec succ√®s", 
      user: newUser 
    });
  } catch (error) {
    console.error("‚ùå Erreur cr√©ation utilisateur:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message 
    });
  }
};

// üîπ R√©cup√©rer tous les utilisateurs (seulement les actifs)
exports.getUsers = async (req, res) => {
  try {
    const users = await User.find({ actif: true }).select("-password");
    res.status(200).json(users);
  } catch (error) {
    console.error("‚ùå Erreur r√©cup√©ration utilisateurs:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message 
    });
  }
};

// üîπ R√©cup√©rer un utilisateur par ID (seulement si actif)
exports.getUserById = async (req, res) => {
  try {
    const user = await User.findOne({ _id: req.params.id, actif: true }).select("-password");
    if (!user) {
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }
    res.status(200).json(user);
  } catch (error) {
    console.error("‚ùå Erreur r√©cup√©ration utilisateur:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message 
    });
  }
};

// üîπ Mettre √† jour un utilisateur
exports.updateUser = async (req, res) => {
  try {
    const { password, ...updateData } = req.body;
    const userId = req.params.id;

    // Emp√™cher la modification du r√¥le et email
    delete updateData.role;
    delete updateData.email;

    // R√©cup√©rer l'utilisateur pour conna√Ætre son type
    const existingUser = await User.findById(userId);
    if (!existingUser) {
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }

    // Hasher le mot de passe si fourni
    if (password) {
      updateData.password = await bcrypt.hash(password, 10);
    }

    let updatedUser;

    // Utiliser le mod√®le appropri√© selon le r√¥le
    if (existingUser.role === "SALARIE") {
      // Pour Salari√©, utiliser le mod√®le Salarie
      updatedUser = await Salarie.findByIdAndUpdate(
        userId,
        updateData,
        { new: true, runValidators: true }
      ).select("-password");
    } else if (existingUser.role === "STAGIAIRE") {
      // Pour Stagiaire, utiliser le mod√®le Stagiaire
      updatedUser = await Stagiaire.findByIdAndUpdate(
        userId,
        updateData,
        { new: true, runValidators: true }
      ).select("-password");
    } else {
      // Pour ADMIN_RH, utiliser le mod√®le User de base
      updatedUser = await User.findByIdAndUpdate(
        userId,
        updateData,
        { new: true, runValidators: true }
      ).select("-password");
    }

    if (!updatedUser) {
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }

    res.status(200).json({ 
      message: "Utilisateur mis √† jour avec succ√®s", 
      user: updatedUser 
    });
  } catch (error) {
    console.error("‚ùå Erreur mise √† jour:", error);
    
    // Gestion sp√©cifique des erreurs de duplication
    if (error.code === 11000) {
      if (error.keyPattern && error.keyPattern.matricule) {
        return res.status(400).json({ message: "Ce matricule est d√©j√† utilis√©" });
      }
      if (error.keyPattern && error.keyPattern.email) {
        return res.status(400).json({ message: "Cet email est d√©j√† utilis√©" });
      }
    }
    
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message 
    });
  }
};

// üîπ Supprimer un utilisateur (soft delete)
exports.deleteUser = async (req, res) => {
  try {
    const userId = req.params.id;
    
    console.log(`üóëÔ∏è Tentative de suppression de l'utilisateur: ${userId}`);
    
    // V√©rifier d'abord si l'utilisateur existe
    const userExist = await User.findById(userId);
    if (!userExist) {
      console.log(`‚ùå Utilisateur ${userId} non trouv√©`);
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }

    console.log(`üìã Utilisateur trouv√©: ${userExist.nom} ${userExist.prenom} (${userExist.role})`);

    // Soft delete - marquer comme inactif
    const user = await User.findByIdAndUpdate(
      userId,
      { actif: false },
      { new: true }
    );

    if (!user) {
      console.log(`‚ùå √âchec de la mise √† jour de l'utilisateur ${userId}`);
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }

    console.log(`‚úÖ Utilisateur ${userId} d√©sactiv√© avec succ√®s`);

    res.status(200).json({ 
      success: true,
      message: "Utilisateur d√©sactiv√© avec succ√®s",
      user: {
        _id: user._id,
        nom: user.nom,
        prenom: user.prenom,
        email: user.email,
        role: user.role,
        actif: user.actif
      }
    });
  } catch (error) {
    console.error("‚ùå Erreur suppression:", error);
    res.status(500).json({ 
      success: false,
      message: "Erreur serveur lors de la suppression", 
      error: error.message 
    });
  }
};

// üîπ R√©activer un utilisateur
exports.activateUser = async (req, res) => {
  try {
    const user = await User.findOneAndUpdate(
      { _id: req.params.id },
      { actif: true },
      { new: true }
    ).select("-password");

    if (!user) {
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }

    res.status(200).json({ 
      message: "Utilisateur r√©activ√© avec succ√®s", 
      user 
    });
  } catch (error) {
    console.error("‚ùå Erreur activation:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message 
    });
  }
};

// üîπ R√©cup√©rer l'utilisateur connect√©
exports.getCurrentUser = async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select("-password");
    
    if (!user) {
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }
    
    res.status(200).json(user);
  } catch (error) {
    console.error("‚ùå Erreur r√©cup√©ration profil:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message 
    });
  }
};

// üîπ Mettre √† jour l'utilisateur connect√©
exports.updateCurrentUser = async (req, res) => {
  try {
    const { password, ...updateData } = req.body;
    
    // Emp√™cher la modification de champs sensibles
    const forbiddenFields = ["role", "dateEmbauche", "dateNaissance", "sexe", "email", "matricule"];
    forbiddenFields.forEach(field => delete updateData[field]);

    // Hasher le mot de passe si fourni
    if (password) {
      updateData.password = await bcrypt.hash(password, 10);
    }

    const user = await User.findByIdAndUpdate(
      req.user.id, 
      updateData, 
      { new: true, runValidators: true }
    ).select("-password");

    if (!user) {
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }

    res.status(200).json({ 
      message: "Profil mis √† jour avec succ√®s", 
      user 
    });
  } catch (error) {
    console.error("‚ùå Erreur mise √† jour profil:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message 
    });
  }
};

// üîπ R√©cup√©rer les utilisateurs d√©sactiv√©s (optionnel)
exports.getUsersDesactives = async (req, res) => {
  try {
    const users = await User.find({ actif: false }).select("-password");
    res.status(200).json(users);
  } catch (error) {
    console.error("‚ùå Erreur r√©cup√©ration utilisateurs d√©sactiv√©s:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message 
    });
  }
};